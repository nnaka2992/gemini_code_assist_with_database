# Prisma ORM & Database Convention Guide
## 1. Introduction
### 1.1. Purpose
This document is the single source of truth for conventions related to our Prisma ORM schema and underlying PostgreSQL database. Its purpose is to establish a shared standard that ensures consistency, reduces cognitive load, and streamlines development. Adhering to these conventions is mandatory for all database-related work.

### 1.2. Scope
These conventions cover project configuration, naming, modeling, data integrity, and code style within the schema.prisma file. They also dictate how we interact with database features that Prisma does not directly manage, such as triggers and permissions.

### 1.3. Guiding Principles
Clarity over cleverness: Code should be easy to read and understand.

Consistency over preference: We follow the rules, even if we have personal preferences.

Explicitness over implicitness: We define structures and relationships clearly rather than relying on magic.

## 2. Core Principles
### 2.1. The Schema is the Source of Truth
The schema.prisma file is the absolute and only source of truth for the database schema. All changes to tables, columns, data types, indexes, or relations MUST be made in schema.prisma first and then applied to the database via a Prisma migration. Direct database modifications with ALTER TABLE are strictly forbidden.

### 2.2. Non-Modeled Objects
Database objects that are not represented in the Prisma schema MUST be managed in version-controlled .sql files. This includes:

Database triggers (e.g., for archival).

Data Control Language (DCL) for managing roles and permissions (GRANT, REVOKE).

## 3. Project Configuration
### 3.1. Datasource
The datasource block MUST be configured for PostgreSQL. A comment indicating the target PostgreSQL version is required for clarity.

```
datasource db {
  // Our project uses PostgreSQL version 17.
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

### 3.2. Generator
The generator block MUST be configured to use prisma-client-js.

```
generator client {
  provider = "prisma-client-js"
}
```

## 4. Naming Conventions
We enforce a strict separation between Prisma schema naming (for the application layer) and database naming (for the storage layer). This is achieved using @@map and @map.

| Element | Prisma Schema (schema.prisma) | Database (PostgreSQL) | Example |
| Model/Table | PascalCase, Singular | snake_case, Plural | model User -> @@map("users") |
| Field/Column | camelCase | snake_case | field firstName -> @map("first_name") |
| Foreign Key | camelCase (e.g., authorId) | snake_case (e.g., author_id) | authorId String -> @map("author_id") |

## 5. Modeling Conventions
### 5.1. Primary Keys & Multi-Tenancy
All tenant-aware tables MUST use a composite primary key of (companyId, id).

- id Field: This is the record's unique identifier within a tenant.
  - Type: String
  - Database Type: UUID
  - Value: MUST be a uuidv7. The uuidv7 value MUST be generated by the application layer before insertion, not by the database. This provides time-ordered, sortable IDs without requiring a database round-trip.

- companyId Field: This is the foreign key to the Company model, defining tenant ownership.
  - Type: String
  - Database Type: UUID

```
model User {
  id        String @db.Uuid
  companyId String @db.Uuid
  // ... other fields

  @@id([companyId, id])
  @@map("users")
}
```

### 5.2. Many-to-Many Relations
Implicit many-to-many relations are forbidden. All many-to-many relations MUST be modeled with an explicit join table. This provides clarity and allows for adding metadata to the relationship itself (e.g., an assignedAt timestamp).

- Naming: The join model is named by combining the two model names in PascalCase (e.g., Post + Category -> PostsToCategories).

```
model Post {
  id           String             @db.Uuid
  // ...
  categories   PostsToCategories[]
  
  @@map("posts")
}

model Category {
  id      String             @db.Uuid
  // ...
  posts   PostsToCategories[]

  @@map("categories")
}

model PostsToCategories {
  postId     String   @db.Uuid
  categoryId String   @db.Uuid
  assignedAt DateTime @default(now())
  
  post       Post     @relation(fields: [postId], references: [id])
  category   Category @relation(fields: [categoryId], references: [id])

  @@id([postId, categoryId])
  @@map("posts_to_categories")
}
```

### 5.3. Enum Convention
You MUST use Prisma's enum type for managing sets of static, internal application values.

    Rationale: Prisma's enum provides full type-safety in the generated client. In PostgreSQL, it maps to a TEXT column with a CHECK constraint, which avoids the migration complexities of native database ENUM types while still enforcing data integrity at the database level.

- Naming: The enum name MUST be PascalCase. The values MUST be SCREAMING_SNAKE_CASE.

Example:
```
// REQUIRED CONVENTION for static values
enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

model Order {
  id      String      @id
  status  OrderStatus @default(PENDING)
  // ...

  @@map("orders")
}
```

## 6. Data Integrity & Lifecycle
### 6.1. Mandatory Timestamps
All tables MUST include non-nullable createdAt and updatedAt fields. Prisma will manage these fields automatically.

```
model SomeModel {
  // ...
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // ...
}
```

### 6.2. Referential Integrity
The default referential actions MUST be set as follows:

- `onDelete: Restrict`: This is a critical safety measure for our archival strategy. It prevents cascading deletes that would bypass the archival trigger, ensuring that dependent records must be handled explicitly.

- `onUpdate: Cascade`: This is the standard, safe default for propagating updates to primary keys.

## 7. Field-Level Conventions
### 7.1. Boolean Flags
All fields of type Boolean *MUST* be prefixed with is, has, or can to make their purpose immediately clear.

- `isActive`

- `hasCompletedOnboarding`

- `canPost`

## 8. Schema Structure & Style
### 8.1. Field Ordering
To ensure schema.prisma is highly readable and consistent, fields within a model MUST be declared in the following order:

- `Primary Key(s)` (id, companyId)

- `Scalar Fields` (String, Int, DateTime, etc.)

- `Foreign Key` Fields (authorId, etc.)

- `Relation Fields` (author User @relation(...))
  - Right after Foreign Key fields.

- `Timestamps` (createdAt, updatedAt)

- `Block Attributes` (@@id, @@unique, @@map, @@index)

### 8.2. Index Naming
Use Prisma's default index naming scheme. Do not use the map: argument on an @@index or @unique attribute unless it is absolutely necessary (e.g., to shorten a name that exceeds database limits) and has been approved. Unnecessary custom names create cognitive overhead.
