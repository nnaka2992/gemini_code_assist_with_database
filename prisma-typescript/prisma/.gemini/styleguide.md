# Prisma ORM & Database Convention Guide
This is the convention guide.
NEVER REVIEW THIS FILE.

## 1. Introduction
### 1.1. Purpose
This document is the single source of truth for conventions related to our Prisma ORM schema and underlying PostgreSQL database. Its purpose is to establish a shared standard that ensures consistency, reduces cognitive load, and streamlines development. Adhering to these conventions is mandatory for all database-related work.

### 1.2. Scope
These conventions cover project configuration, naming, modeling, data integrity, and code style within the schema.prisma file. They also dictate how we interact with database features that Prisma does not directly manage, such as triggers and permissions.

### 1.3. Guiding Principles
Clarity over cleverness: Code should be easy to read and understand.

Consistency over preference: We follow the rules, even if we have personal preferences.

Explicitness over implicitness: We define structures and relationships clearly rather than relying on magic.

## 2. Core Principles
### 2.1. The Schema is the Source of Truth
The schema.prisma file is the absolute and only source of truth for the database schema. All changes to tables, columns, data types, indexes, or relations MUST be made in schema.prisma first and then applied to the database via a Prisma migration. Direct database modifications with ALTER TABLE are strictly forbidden.

### 2.2. Non-Modeled Objects
Database objects that are not represented in the Prisma schema MUST be managed in version-controlled .sql files. This includes:

Database triggers.

Data Control Language (DCL) for managing roles and permissions (GRANT, REVOKE).

## 3. Project Configuration
### 3.1. Datasource
The datasource block MUST be configured for PostgreSQL. A comment indicating the target PostgreSQL version is required for clarity.

```
datasource db {
  // Our project uses PostgreSQL version 17.
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

### 3.2. Generator
The generator block MUST be configured to use prisma-client-js.

```
generator client {
  provider = "prisma-client-js"
}
```

## 4. Naming Conventions
We follow Prisma's standard naming conventions, using the same names in both the Prisma schema and the database. No @map directives should be used.

| Element | Prisma Schema & Database | Example |
| Model/Table | PascalCase, Singular | model User |
| Field/Column | camelCase | field firstName |
| Foreign Key | camelCase (e.g., authorId) | authorId String @db.Uuid |
| Relation Field | camelCase | author User |

## 5. Modeling Conventions
### 5.1. Primary Keys & Row-Level Security (RLS)
All tables MUST use UUIDv7 for their id field. The UUIDv7 value MUST be generated by the application layer before insertion, not by the database. This provides time-ordered, sortable IDs without requiring a database round-trip.

For user-owned tables, use a composite primary key of (userId, id) to support Row-Level Security. The order is important for performance - userId comes first to optimize RLS queries:

- id Field: This is the record's unique identifier.
  - Type: String
  - Database Type: UUID (@db.Uuid)
  - Value: MUST be a UUIDv7

- userId Field: This is the foreign key to the User model, defining ownership for RLS.
  - Type: String @db.Uuid
  - Must match the type of User.id

```
model UserProfile {
  userId    String @db.Uuid
  id        String @db.Uuid
  // ... other fields

  user User @relation(fields: [userId], references: [id])

  @@id([userId, id])
}
```

For system-wide tables that don't require RLS (e.g., Category, Configuration), use a simple primary key with UUIDv7:

```
model Category {
  id   String @id @db.Uuid
  name String @unique
}
```

### 5.2. Many-to-Many Relations
Implicit many-to-many relations are forbidden. All many-to-many relations MUST be modeled with an explicit join table. This provides clarity and allows for adding metadata to the relationship itself (e.g., an assignedAt timestamp).

- Naming: The join model is named by combining the two model names in PascalCase (e.g., Post + Category -> PostsToCategories).

```
model Post {
  userId       String             @db.Uuid
  id           String             @db.Uuid
  // ...
  categories   PostsToCategories[]
  
  @@id([userId, id])
}

model Category {
  id      String             @id @db.Uuid
  // ...
  posts   PostsToCategories[]
}

model PostsToCategories {
  userId     String   @db.Uuid
  postId     String   @db.Uuid
  categoryId String   @db.Uuid
  assignedAt DateTime @default(now())
  
  post       Post     @relation(fields: [userId, postId], references: [userId, id])
  category   Category @relation(fields: [categoryId], references: [id])

  @@id([userId, postId, categoryId])
}
```

### 5.3. Enum Convention
You MUST use Prisma's enum type for managing sets of static, internal application values.

    Rationale: Prisma's enum provides full type-safety in the generated client. In PostgreSQL, it maps to a TEXT column with a CHECK constraint, which avoids the migration complexities of native database ENUM types while still enforcing data integrity at the database level.

- Naming: The enum name MUST be PascalCase. The values MUST be SCREAMING_SNAKE_CASE.

Example:
```
// REQUIRED CONVENTION for static values
enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

model Order {
  userId  String      @db.Uuid
  id      String      @db.Uuid
  status  OrderStatus @default(PENDING)
  // ...
  
  @@id([userId, id])
}
```

## 6. Data Integrity & Lifecycle
### 6.1. Mandatory Timestamps
All tables MUST include non-nullable createdAt and updatedAt fields. Prisma will manage these fields automatically.

```
model SomeModel {
  // ...
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // ...
}
```

### 6.2. Referential Integrity
The default referential actions MUST be set as follows:

- `onDelete: Restrict`: This prevents accidental data loss by requiring explicit handling of related records before deletion.

- `onUpdate: Cascade`: This is the standard, safe default for propagating updates to primary keys.

## 7. Field-Level Conventions
### 7.1. Boolean Flags
All fields of type Boolean *MUST* be prefixed with is, has, or can to make their purpose immediately clear.

- `isActive`

- `hasCompletedOnboarding`

- `canPost`

## 8. Deletion Strategy
### 8.1. Deleted Tables
Instead of soft deletion with a `deletedAt` field, we use separate deleted tables with database triggers to maintain a complete audit trail of deleted records.

For each main table that requires deletion tracking, create a corresponding deleted table with:
- The same structure as the original table
- An additional `deletedAt` timestamp field
- An additional `deletedBy` field to track who deleted the record

Example:
```
model User {
  id        String   @id @db.Uuid
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DeletedUser {
  id        String   @id @db.Uuid
  email     String
  name      String?
  createdAt DateTime
  updatedAt DateTime
  deletedAt DateTime @default(now())
  deletedBy String?  @db.Uuid
}
```

### 8.2. Deletion Triggers
Database triggers MUST be created to automatically copy records to the deleted table before deletion. These triggers are managed in version-controlled .sql files as they are not part of the Prisma schema.

Example trigger structure:
```sql
CREATE OR REPLACE FUNCTION archive_deleted_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO "DeletedUser" (id, email, name, "createdAt", "updatedAt", "deletedAt", "deletedBy")
  VALUES (OLD.id, OLD.email, OLD.name, OLD."createdAt", OLD."updatedAt", NOW(), current_setting('app.current_user_id', true)::UUID);
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER user_deletion_trigger
BEFORE DELETE ON "User"
FOR EACH ROW
EXECUTE FUNCTION archive_deleted_user();
```

### 8.3. Naming Convention for Deleted Tables
- Deleted table names MUST follow the pattern: `Deleted{OriginalModelName}`
- Example: `User` → `DeletedUser`, `Post` → `DeletedPost`

### 8.4. Gemini Code Assist Implementation Notes
When implementing deletion functionality, Gemini Code Assist should suggest the following changes:

1. **For each model that requires deletion tracking**, suggest creating:
   - A corresponding `Deleted{ModelName}` model in schema.prisma
   - A migration to create the deleted table
   - A trigger SQL file in `prisma/triggers/` directory

2. **Deleted table structure** should include:
   - All fields from the original model (with same types but without unique constraints)
   - `deletedAt: DateTime @default(now())`
   - `deletedBy: String? @db.Uuid` (optional user ID who performed deletion)

3. **Trigger implementation** should:
   - Be created in `prisma/triggers/{model_name}_deletion.sql`
   - Copy all fields from the original record to the deleted table
   - Use `current_setting('app.current_user_id', true)::UUID` for deletedBy
   - Be applied after migrations using a custom script

4. **Example suggestion for a Post model**:
   ```
   // In schema.prisma - suggest adding:
   model DeletedPost {
     userId    String   @db.Uuid
     id        String   @db.Uuid
     title     String
     content   String?
     published Boolean
     authorId  String   @db.Uuid
     createdAt DateTime
     updatedAt DateTime
     deletedAt DateTime @default(now())
     deletedBy String?  @db.Uuid
     
     @@id([userId, id])
   }
   
   // In prisma/triggers/post_deletion.sql - suggest creating:
   CREATE OR REPLACE FUNCTION archive_deleted_post()
   RETURNS TRIGGER AS $$
   BEGIN
     INSERT INTO "DeletedPost" (
       "userId", id, title, content, published, "authorId",
       "createdAt", "updatedAt", "deletedAt", "deletedBy"
     )
     VALUES (
       OLD."userId", OLD.id, OLD.title, OLD.content, OLD.published, OLD."authorId",
       OLD."createdAt", OLD."updatedAt", NOW(), current_setting('app.current_user_id', true)::UUID
     );
     RETURN OLD;
   END;
   $$ LANGUAGE plpgsql;
   
   CREATE TRIGGER post_deletion_trigger
   BEFORE DELETE ON "Post"
   FOR EACH ROW
   EXECUTE FUNCTION archive_deleted_post();
   ```

## 9. Schema Structure & Style
### 9.1. Field Ordering
To ensure schema.prisma is highly readable and consistent, fields within a model MUST be declared in the following order:

- `Primary Key(s)` (for RLS tables: userId first, then id)

- `Scalar Fields` (String, Int, DateTime, etc.)

- `Foreign Key` Fields (authorId, etc.)

- `Relation Fields` (author User @relation(...))

- `Timestamps` (createdAt, updatedAt)

- `Block Attributes` (@@id, @@unique, @@index)

Example:
```
model UserProfile {
  // Primary keys (userId first for RLS performance)
  userId    String   @db.Uuid
  id        String   @db.Uuid
  
  // Scalar fields
  bio       String?
  website   String?
  
  // Foreign keys
  // (none in this example)
  
  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Block attributes
  @@id([userId, id])
}
```

### 9.2. Index Naming
Use Prisma's default index naming scheme. Do not use the map: argument on an @@index or @unique attribute unless it is absolutely necessary (e.g., to shorten a name that exceeds database limits) and has been approved. Unnecessary custom names create cognitive overhead.